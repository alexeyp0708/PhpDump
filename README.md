# Alpa\PhpDump  

#### Разделы
* [Интеграция в MODX](https://github.com/ALexeyP0708/PhpDump/blob/dev/Doc/integration_in_MODX.md)

#### Описание

* Выводит ошибки  в консоли.
* Выводит переменные в консоли.
* Выводит массивы и объекты в консоли.
* Выводит детальную информацию об объектах и классах рекурсивно.  
* Возможность анализа "Тяжелых объектов"  
* Отсутствие ограничения вложенности в объектах за счет исключения петель(замыкания по ссылки).  
* Можно целенаправленно оставлять следы (методы дебага). Они будут исполняться, если та или иная точка будет активирована. Такое поведение необходимо в случаях, если необходимо запросить комплексную генерацию дампа в целях отследить поведение для конкретного компонента или группы компонентов.

![image](https://habrastorage.org/webt/cy/bv/4q/cybv4quntc0ubqt9l2mqz8dzbfw.png)  
![image](https://habrastorage.org/webt/ib/p9/n-/ibp9n-vhwgnglggwiyb52rnxvnu.png)  
![image](https://habrastorage.org/webt/1q/lx/bb/1qlxbb_a8mvglucbqn2v1tri3sq.png)  

#### Требования
PHP 7
Git + Composer  

####  Загрузка и установка 

Этапы
- Установка для всех проектов, через Composer глобально.
- Установка для всех проектов через Composer локально.
- Установка через GIT


##### Подготовка к установке.

Есть скрипты, которые необходимо подключать повсеместно на вашей рабочей станции.  
В PHP такую возможность можно осуществить через настройки auto_prepend_file и auto_append_file.  
Для этого в файле php.ini необходимо прописать параметр `auto_prepend_file= dirictory/name_file.php`  
Для Apache можно в файле .htaccess прописать строку `php_value auto_prepend_file dirictory/name_file.php`  
В других случаях, смотрите документацию вашего сервера.  

Для таких целей создадим файл `init_prepend_scripts.php` в котором будем прописывать файлы автозагрузчиков и/или инициализацию скриптов.  
Чтобы не корректировать постоянно настройки, в случаях миграции проекта или изменения местоположения подключаемых компонентов, предлагается внедрять переменные среды окружения, которые будут указывать на местоположение компонентов, а также внедрить переменную которая укажет на файл `init_prepend_scripts.php` и будет фигурировать в файлах настроек php сервера. cм [Добавление переменных окружения](Doc/add_var_in_environment.md)

1. Создадим и установим переменную среды `PHP_AUTO_PREPEND_FILE=absolute_path/init_prepend_scripts.php`.  
PHP_AUTO_PREPEND_FILE lолжна определяться до запуска сервера. Для таких целей PHP_AUTO_PREPEND_FILE необходимо обьявить в ОС.

2. Установим настройки в php.ini
`auto_prepend_file=${PHP_AUTO_PREPEND_FILE}`
Если нет возможности установить переменную PHP_AUTO_PREPEND_FILE, тогда просто пропишите
`auto_prepend_file=absolute_path/init_prepend_scripts.php`, где absolute_path - полный путь до файла init_prepend_scripts.php.
Можно настройку auto_prepend_file устанавливать только для конкретных проектов. Для Apache это делается через файл .htaccess, где пропишем настройку `php_value auto_prepend_file absolute_path/init_prepend_scripts.php` .

3. Формируем файл `absolute_path/init_prepend_scripts.php` 
```php 
<?php 
//-- init Composer global.
	if(false!==($path=getenv('COMPOSER_HOME'))){
		$composer_home=$path;
	} else if(false!==($path=getenv('APPDATA'))){ // для windows
		$composer_home=$path.'/Composer';
	} else {
		// для *nix систем
		if(false!==($path=getenv('XDG_CONFIG_HOME'))){
			$composer_home=$path.'/composer';
		} else if(false!==($path=getenv('HOME'))){
			$composer_home=$path.'/.composer';
		}
	}
	// подключаем проекты которые установлены глобально. через composer global require
	if(file_exists($composer_home.'/vendor/autoload.php')){
		include $composer_home.'/vendor/autoload.php';
	}
	
// -- end Init Composer Global
```

4. Перезапустите сервер.

#####  Установка для всех проектов, через Composer глобально.
1.	Так как приложение и зависимости еще не добавлены в packagist, прописываем репозитории
	`$ composer global config repositories.Alpa\PhpDump git https://github.com/ALexeyP0708/PhpDump.git`
	`$ composer global config repositories.Alpa\EntityDetails git https://github.com/ALexeyP0708/EntityDetails.git`
2. Подтягиваем PhpDump
	`$ composer global require Alpa/PhpDump":"1.*`

3.	Далее команда
	`$ composer global install` если композер еще не инициализирован глобально 
	Или `$ composer global update` обновить глобальные компоненты
	Или `$ composer global dump-autoload`  обновляет глобальный автозагрузчик. 
4. Дописываем в конец файла `init_prepend_scripts.php` код:
```php
	// инициализируем  Php Dump;
	\Alpa\PhpDump\Manager::includeFileInit();
```

##### Установка для всех проектов через Composer локально.  
Это способ установки, когда компонент установлен отдельно от всех проектов

1. Установка локально происходит по тем  же командам (пункты 1-4) предыдущего раздела, но только без директивы `global`
2. Устанавливаем переменную среды `PHP_DUMP_PATH=path/phpdump/extension` где значением является путь к каталогу компонента PhpDump.
	Переменную среды можно установить и в .htaccess `SetEnv PHP_DUMP_PATH absolute/path/PhpDump`, если в настройках Apache для вашего домена установлен параметр `AllowOverride` в состояние `All` 
	ВНИМАНИЕ: переменную среды можно установить другую, если вы осуществили специальную сборку проекта локально и в котором присутствует компонент PhpDump. Тогда вам придется заменить упоминания PHP_DUMP_PATH на имя вашей переменной среды в коде описанном ниже.
3. Дописываем в конец файла `init_prepend_scripts.php` код
```php
// -- Init Php Dump	
	if(false===($path=getenv('PHP_DUMP_PATH'))){
		// эмулируем добавление PHP_DUMP_PATH в случае если не знаете как на вашем сервере установить переменную среды.
		putenv('PHP_DUMP_PATH='.__DIR__.'/relative/patch/dirictories/PhpDump');// указываем достоверный путь
	if(false!==($path=getenv('PHP_DUMP_PATH'))){
		include $path.'/vendor/autoload.php';
		\Alpa\PhpDump\Manager::includeFileInit();
	}
// -- End  Init Php Dump
```

Для подключения проекта на работающем сайте, принцип действий не изменяется. 
Необходимо в отдельную папку установить проект локально, после чего для php установить настройки
 `auto_prepend_file= dirictory/init_prepend_scripts.php` или `auto_prepend_file=${PHP_AUTO_PREPEND_FILE}`, 
 установить переменные среды PHP_AUTO_PREPEND_FILE и PHP_DUMP_PATH, скопировать или создать файл `init_prepend_scripts.php` в соответсвующую дирикторию.

##### Установка через GIT 
1. Команда для терминала
`$ git clone https://github.com/ALexeyP0708/PhpDump.git`
После клонирования, необходимо установить зависимости.
2. Запустите команду `$ composer install`
3. Исполните пункты 2,3 главы **Установка для всех проектов через Composer локально.**


#### Установка  PhpDumpConsole Chrome Extensions

В Google Chrome переходим в раздел *Расширения*, включаем режим разработчика (в верхнем правом углу), далее `Загрузить распакованное расширение`  
Указываем директорию `[directory PhpDump]/ChromeExtension/PhpDumpConsole_v1.1`.   
В панели появится красный значок в виде прицела -шестеренка в кругу. Если при нажатии шестеренка не превращается в синий цвет, то или сервер не поддерживает PhpDump или клиент не прошел авторизацию.



#### Проверка работоспособности.

ознакомьтесь с файлом `[dirictory Php Dump]/tests/test_debugManager.php`

К каталогу где установлен PhpDump должен быть веб доступ и свободная маршрутизация к сценариям.  
Допустим  вы установили PhpDump  в  `/sites/www/mysite/TestPhpDump` а веб доступ к сайту `http://mysite/` тогда для запуска сценария теста 
`http://mysite/TestPhpDump/tests/test_debugManager.php`

Запустится страница с генерированными ошибками. Запустим консоль Google Chrome и нажимаем шестеренку в панели приложений. Страница перезагрузится, шестеренка превратится в синий цвет.  Вся информация теперь отобразится в консоли. 




#### Принцип реализации 

1. Служебная информация между клиентом и сервером обменивается через заголовки. 
2. После клиент запрашивает тело дампа  для вывода результата в консоли.
3. При формировании дампа, данные дампа в потоке записываются в json файл и после, при запросе клиентом, 
данные json файла отдаются клиенту.
4. Дамп  можно включать и отключать для конкретных вкладок.
5. Структура построена таким образом, что дамп данных формируется для каждого запроса отдельно. Тем самым дамп будет формироваться для каждого пользователя свой для каждого запроса.
6. Отображает дамп Ajax запросов и динамически построенных через PHP контент файлов (js,css,img....). 
7. При желании, возможность анализировать дамп через файл.
8. Если Php Dump установлен, то можно целенаправленно оставлять следы (методы php dump). Они будут исполняться, если та или иная точка будет активирована. См ниже управление через turn_on. Такое поведение необходимо в случаях если необходимо запросить комплексную генерацию дампа в целях отследить поведение для конкретного компонента или группы компонентов. Для продакшен версии, встраивается класс заглушка для следов, или проект зачищается от характерных следов.

**Перспективы:**
- Передача дампа через web socket . Тем самым сегменты дампа будут сразу передаваться клиенту, даже если скрипт вошел в цикличную бесконечность  
- Возможность привязки вкладки к работе конкретного скрипта. Это необходимо когда скрипт выполняется чере CLI или запущен демон.  
- Управление приложением через команды.  
- При цикличности, исключить передачу повторных данных.  
- Импорт экспорт дампа.


 Для дальнейшей работы, можете отредактировать файл настроек.
	
#### Файл настроек. **"src/init_php_dump.php"**  
В файле настроек можно включать отключать PhpDump, или ограничивать запись дампа конкретными данными,
включать отключать бектрейс, изменять каталог сохранения файлов дампа.  
Также в файле можно объявить свои функции-обертки для конкретных методов или назначить псевдоним для рабочего класса.
Также в файле настроек устанавливаются настройки авторизации. 


#### Настройки безопасности.

PhpDump на данный момент не рассчитан на профессиональную работу, поэтому условия безопасности минимальны.  
Если вы решили PhpDump прикрепить к действующему сайту на просторе интернет, то  в файле   `src/init_php_dump.php` изменить следующие настройки для авторизации:


```php

$settings=[

    'hashkeys'=>[

     'HashKey'=>[ // любой ключ в виде строки (латиница).Будет являться публичным ключём

      'key'=>'HashKey', // дублируем строку ключа

      'greeting_server'=>'greeting_server', // ключ в виде строки для авторизации на стороне сервера

      'greeting_client'=>'greeting_client' // ключ для авторизации на стороне клиента.  

     ]

]

];
```

На стороне клиента в консоли, в выпадающем списке 'Java Scripts Context' выбрать  PhpDumpConsole  и в консоли введите код  

```js

dm.setHashKey({

 hashkey:'HashKey',

 greeting_server:'greeting_server',  

 greeting_client:'greeting_client'

 });  
//где параметры hashkey , greeting_server, greeting_client устанавливаете такие же как и на сервере.
dm.bindHashKeyDomain({hashkey:'HashKey',domain:'global'}); // или domain:'your_domain' 
//если domain='global'  будет применяться по умолчанию для всех сайтов к которым не установлена авторизация по другому ключу.  

```

#### Минимальные настройки дампа

```php
$dump_settings=[ 
	'turn_on'=>['all'=>true], 
	'unset_dump_after'=>true, 
	'debug_backtrace'=>false
];
$dump_fields=[
	'path'=>__DIR__.'/../temp', 
	//'user'=>'', // Can be changed by the client part (via the browser console)
	//'context'=>'',// Can be changed by the client part (via the browser console)
	//'group'=>'', //Can be changed by the client part (via the browser console)
	//'name'=>'', // only for server part
];
```

Если необходимо отключить работу дампа, достаточно указать `$dump_settings['turn_on']=false;  `
Если необходимо включить дамп, то укажите в настройках массив `$dump_settings['turn_on']=[];` Данным массивом может управлять клиент.
В массиве можно перечислить сегменты данных которые вы хотите отключить или включить для их вывода указанных под  меткой.
Парсинг Меток реализован специально под пространство имен.  И если вы ходите отключить или включить группу меток,
 то достаточно указать пространство имен этой группы.  
 К примеру есть метки категории "Producer\Product\Class" и метки категории "Producer\Product\Class2  
```php
 // Отключаем все метки кроме ошибок и меток категории "Producer\\Product\\Class"
 $dump_settings['turn_on']=['all'=>false,'Errors':true,'Producer\\Product\\Class'=>true]; 
 // Отключаем все метки кроме ошибок и меток категории Producer\\Product. Данные с метками Producer\\Product\\Class и Producer\\Product\\Class2  будут отображаться 
 $dump_settings['turn_on']=['all'=>false,'Errors':true,'Producer\\Product'=>true]; 
 // Отключаем вывод ошибок с кодом 1024 и данные с меткой Producer\\Product::method
  $dump_settings['turn_on']=['all'=>true,'Errors\\1024':false,'Producer\\Product'=>false];
 ```
 Если необходимо вывод backtrace  
```php
	$dump_settings['debug_backtrace']= true;
```

Если вы хотите оставлять сгенерированые файлы дампов, то: 
```php
	$dump_settings['unset_dump_after']= false;
```

Если необходимо изменить каталог сохранение файлов дампа:
```php
	$dump_fields['path']='new dirictory';
```

Файлы имеют некий путь сохранения и строятся по следующему принципу:  

`user/context/timestamp_group_name.json`

```php
	//если необходимо группу файлов дампа выделить под конкретным пользователем. По умолчанию или сессия или other_user. Определяется сервером.
	$dump_fields['user']='name';

	// Если необходимо выделить некую группу файлов в рамках контекста (в рамках одной вкладки или псевданима). По умолчанию клиент передает номер вкладки.   Назначается только клиентом.
	$dump_fields['context']='num_tab';

	// если файлы дампа необходимо сгруппировать. Например для выполнения конкретных сценариев. По умолчанию случайное число. Может определяться клиентом.  сервер переопределяет.
	$dump_fields['group']='name_group';
	// указывает суфикс названия (имя) файла. Генерируется динамически. Определяет только сервер.  
	$dump_fields['name']='name';
```
При изменении настроек для $dump_fields на сервере, они начнут применяться только для новых вкладок.  
При использовании PhpDump несколькими пользователями в категории other_user и при совпадении контекста "context"(например одинаковый id вкладки),
есть шанс что случайные числа для 'group' и 'name' пересекутся и возникнет конфликт формирования файлов дампа (создание файла под одним и тем же именем или чтение чужого дампа).  
Но такой шанс не велик, так как  PhpDump будут использовать одновременно небольшая группа разработчиков для одного сервера.  
Если все таки хотите свести конфликт к минимуму, то  можно сделать так $dump_fields['name']=uniqid().uniqid().uniqid(); или задайте иную логику.
Некоторые настройки можно менять со стороны клиента.

В файле настроек,   для класса Alpa\PhpDump\Manager указан псвдоним \deb, который реализует статические методы для выполнения записи данных в дамп. В файле можно указать свой псевдо класс. Можно также указать функции обертки.
Зачем псевдо класс:
- для удобства написания. Удобней писать так \deb::print('Hello'); чем так \Alpa\PhpDump\Manager::print('Hello');
- Если вы целенаправлено оставляете следы (методы php dump), чтобы по желанию запрашивать генерацию дампа для конкретных точек (равносильно логам),
 то в продакшен версии можно вместо отключения php dump, создать  класс заглушку, где будет использован магический метод \_\_call или  методы заглушки. Для функций оберток достаточно обьявить функции пустыми. 
#### Статические Методы класса для использования в PHP сценарии:
```php
	\deb::vdump($var,$label='')// - результат выполнение var_dump 
	\deb::vexport($var,$label='');//- результат выполнение var_export
	\deb::print($var,$label='');// - выводит результат переменной. (в том числе массивы и объекты, рекурсивно анализируя)
	\deb::dump($var,$label='');// - также выводит результат переменной. Если массив или объект, рекурсивно анализирует их. По каждому обьекту предоставляет детальную информацию.
	\deb::infoClass($var,$label='');// информация о классе
	\deb::error($errno = false, $errstr, $errfile = false, $errline = false, $errcontext = false)
```



#### Работа в Консоли браузера.


При включении приложения для вкладки, страница сайта перезагрузится. PhpDump перейдет в рабочее состояние.
При этом инициализируются первичные настройки для вкладки и для сервера.
Последующие полученные настройки со стороны сервера являются динамическими (настройки сформированные клиентом и сервером)
 и действуют в момент существования вкладки и не сохраняются при ее закрытии или отключения для нее PhpDump расширения.

Возможно покажется не удобным, но для управления сервером и клиентом используется консоль и вызов соответствующего API.
Чтобы применить это api в действии, необходимо в консоли из списка приложений 
(выпадающий список. размещается в верхнем левом углу консоли и отображается по умолчанию "top") выбрать  PhpDumpConsole. 

#### API  для работы в консоле

```js
	// dm - обьект для работы с методами команд
	dm.renderStack();//вывод в консоль стек данных дампа  по всем запросам страницы
	dm.renderDump(); //Вывод в консоль обьект дампа
	dm.renderSettings(callback=false); //отображает настройки для данной страницы(по url). callback function если указан то обработает результат callback -ом.   
```
```js	
	var settings=[{
			url:'', // урл к которому будут применены настройки. по умолчанию  window.location.href. 	  
			regexp:'', // регулярное выражение для дочерних ресурсов сайта. url  и regexp работают в паре см.  `url=url.trim()!=''?'^'+$url:''; new RegExp(url+regexp,'i');
			turn_on:{ // см PHP $dump_settings['turn_on']
				'all':false ,  
				'group2\\group1':true, 
				'group3':true,
				'namespace/name':true, 
			}, 
			debug_backtrace:false, см PHP $dump_settings['debug_backtrace']
		}];
	dm.setSettings(settings,save=false); // устанавливает настройки для сайта  и паттерну для него.  save =true -настройки сохранятся, и будут применяться постоянно.
	/*
		**Внимание**: чтобы изменить настройки для сайта  которые были введены ранее, то параметры url и regexp должны совпадать с параметрами сравнения.
		в противном случае эти настройки будут добавлены как новые.
		Также если несколько таких правил будут совпадать с url то настройки будут объединяться рекурсивно при вычислении настроек сайта, а
		при совпадении свойств - заменены  последними настройками в стеке настроек. (принцип рекурсивного объединения массивов) 
	*/
```

```js	
	var settings =[{url:'url',regexp:'regexp',type:'link'}];
	dm.clearSettings(settings,save=false); //сбрасывает настройки.
	// type ='link', сбрасывает все настройки, чьи паттерны подходят к url.
	// type!='link', сбрасывает все настройки чьи паттерны идентичны сформированному рег выражению. формирование выражения см. setSettings();.
	// save =true сохранит сброс.
```

```js
	dm.clearAllSettings(save=ture/false); // сбрасывает все настройки
	dm.saveStorageAllSettings(); // сохраняет все изменения , произошедших в настройках.
``` 

```js
//Авторизация
	param={
		hashkey:'HashKey', // ключ по которому проходит авторизация. он может привязываться к любому домену. 
		greeting_server:'greeting_server', // приветствие сервера. пароль сервера. тем самым сервер авторизуется с клиентом. 
		greeting_client:'greeting_client' // приветствие клиента. пароль клиента.  для авторизации клиента с сервером.
	}
	dm.setHashKey(param); // регистрируем/изменяем хашкей 
	dm.deleteHashKey({hashkey:'name'}); // удаляет хашкей.
	dm.bindHashKeyDomain({hashkey:'HashKey',domain:'qwer.qw'});//привязывает хашкей к домену.  тем самым по этому хашкею можно авторизироваться с доменом. 
	//если domain='global' хашкей будет применяться для сайтов к которым не установлен хашкей.  
	dm.unbindHashKeyDomain({domain:'ggg',hashkey:'ggg'});// отвязывает хашкей от домена...
	dm.getAuthHashKeys(callback=false); // запрашивает хашкеи 
	//если  callback =function(data_return){} то обработает запрошенные данные калбеком. Это необходимо порой для проверки и зачистки не нужных хашкеев. 
```

## Возможные проблемы.

E_ERROR: Allowed memory size of ******** bytes exhausted 

Переменная дампа содержит очень большой объект для анализа. Т.к как объект анализируется и по каждому дочернему свойству создается статистика.
Также проблема кроется в json_encode, так как под  json строку выделяется память, а не передается результат в поток.
Решение - увеличить объем памяти в php.
Над проблемой бьются лучшие умы.  НО пока всех все устраивает если не зажираться.  

HTTP ERROR 500 - критическая ошибка  
Если сценарий прекратил Apache (или иной сервер)  то  дамп  не сформируется. При запросе дампа, PhpDump отдаст не сформированный дамп. Клиентская часть не сможет его распознать. 
Для этого придется анализировать в фоновой странице приложения в разделе NETWORK запросы или анализировать файлы дампа. 
 (чтобы файл распознавался json декодерами, при таком аварийном закрытии, надо в конце добавлять квадратную и фигурную скобки -"]}" ) 
 
Если от сервера получен ответ 500 или иные ошибки без погрузки контента (скрипт расширения PhpDumpConsole для контента не будет загружен), то в консоли соответственно ничего не выдаст.  Это связано с тем что, после загрузки страницы, загружается скрипт контента приложения и обменивается данными с приложением.  
Приложение дублирует ответ в консоли фоновой страницы расширения PhpDumpConsole.    
Поэтому ответ можно проанализировать там.  
См Chrome Extensions фоновая страница приложения.

Для ознакомления с обозначениями свойств и методов объекта см https://github.com/ALexeyP0708/EntityDetails



